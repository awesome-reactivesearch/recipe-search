import AppbaseAnalytics from '@appbaseio/analytics';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var Observable = /*#__PURE__*/function () {
  function Observable() {
    this.observers = [];
  }

  var _proto = Observable.prototype;

  _proto.subscribe = function subscribe(fn, propertiesToSubscribe) {
    this.observers.push({
      callback: fn,
      properties: propertiesToSubscribe
    });
  };

  _proto.unsubscribe = function unsubscribe(fn) {
    if (fn) {
      this.observers = this.observers.filter(function (item) {
        if (item.callback !== fn) {
          return item;
        }

        return null;
      });
    } else {
      this.observers = [];
    }
  };

  _proto.next = function next(o, property, thisObj) {
    var scope = thisObj;

    if (!scope && window) {
      scope = window;
    }

    this.observers.forEach(function (item) {
      // filter by subscribed properties
      if (item.properties === undefined) {
        item.callback.call(scope, o);
      } else if (item.properties instanceof Array && item.properties.length && item.properties.includes(property)) {
        item.callback.call(scope, o);
      } else if (typeof item.properties === 'string' && item.properties && item.properties === property) {
        item.callback.call(scope, o);
      }
    });
  };

  return Observable;
}();

function getErrorMessage(msg) {
  return "SearchBase: " + msg;
}
var errorMessages = {
  invalidIndex: getErrorMessage('Please provide a valid index.'),
  invalidURL: getErrorMessage('Please provide a valid url.'),
  invalidComponentId: getErrorMessage('Please provide component id.'),
  invalidDataField: getErrorMessage('Please provide data field.'),
  dataFieldAsArray: getErrorMessage('Only components with `search` type supports the multiple data fields. Please define `dataField` as a string.')
};
var popularSuggestionFields = ['key', 'key.autosuggest'];
var queryTypes = {
  Search: 'search',
  Term: 'term',
  Geo: 'geo',
  Range: 'range'
};
var withClickIds = function withClickIds(results) {
  if (results === void 0) {
    results = [];
  }

  return results.map(function (result, index) {
    return _extends({}, result, {
      _click_id: index + 1
    });
  });
};
var highlightResults = function highlightResults(result) {
  var data = _extends({}, result);

  if (data.highlight) {
    Object.keys(data.highlight).forEach(function (highlightItem) {
      var _extends2;

      var highlightValue = data.highlight[highlightItem][0];
      data._source = _extends({}, data._source, (_extends2 = {}, _extends2[highlightItem] = highlightValue, _extends2));
    });
  }

  return data;
};
var parseHits = function parseHits(hits) {
  var results = [];

  if (hits) {
    results = [].concat(hits).map(function (item) {
      var data = highlightResults(item);
      var result = Object.keys(data).filter(function (key) {
        return key !== '_source';
      }).reduce(function (obj, key) {
        // eslint-disable-next-line
        obj[key] = data[key];
        return obj;
      }, _extends({}, data._source));
      return result;
    });
  }

  return results;
};
var getNormalizedField = function getNormalizedField(field) {
  if (field) {
    // if data field is string
    if (!Array.isArray(field)) {
      return [field];
    }

    if (field.length) {
      var fields = [];
      field.forEach(function (dataField) {
        if (typeof dataField === 'string') {
          fields.push(dataField);
        } else if (dataField.field) {
          // if data field is an array of objects
          fields.push(dataField.field);
        }
      });
      return fields;
    }
  }

  return undefined;
};
function isNumber(n) {
  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);
}
var getNormalizedWeights = function getNormalizedWeights(field) {
  if (field && Array.isArray(field) && field.length) {
    var weights = [];
    field.forEach(function (dataField) {
      if (isNumber(dataField.weight)) {
        // if data field is an array of objects
        weights.push(dataField.weight);
      } else {
        // Add default weight as 1 to maintain order
        weights.push(1);
      }
    });
    return weights;
  }

  return undefined;
};
function flatReactProp(reactProp, componentID) {
  var flattenReact = [];

  var flatReact = function flatReact(react) {
    if (react && Object.keys(react)) {
      Object.keys(react).forEach(function (r) {
        if (react[r]) {
          if (typeof react[r] === 'string') {
            flattenReact = [].concat(flattenReact, [react[r]]);
          } else if (Array.isArray(react[r])) {
            flattenReact = [].concat(flattenReact, react[r]);
          } else if (typeof react[r] === 'object') {
            flatReact(react[r]);
          }
        }
      });
    }
  };

  flatReact(reactProp); // Remove cyclic dependencies i.e dependencies on it's own

  flattenReact = flattenReact.filter(function (react) {
    return react !== componentID;
  });
  return flattenReact;
} // flattens a nested array

var flatten = function flatten(arr) {
  return arr.reduce(function (flat, toFlatten) {
    return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
  }, []);
}; // helper function to extract suggestions

var extractSuggestion = function extractSuggestion(val) {
  if (typeof val === 'object') {
    if (Array.isArray(val)) {
      return flatten(val);
    }

    return null;
  }

  return val;
};

function escapeRegExp(string) {
  if (string === void 0) {
    string = '';
  }

  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

var getPredictiveSuggestions = function getPredictiveSuggestions(_ref) {
  var suggestions = _ref.suggestions,
      currentValue = _ref.currentValue,
      wordsToShowAfterHighlight = _ref.wordsToShowAfterHighlight;
  var suggestionMap = {};

  if (currentValue) {
    var currentValueTrimmed = currentValue.trim();
    var parsedSuggestion = suggestions.reduce(function (agg, _ref2) {
      var label = _ref2.label,
          rest = _objectWithoutPropertiesLoose(_ref2, ["label"]);

      // to handle special strings with pattern '<mark>xyz</mark> <a href="test'
      var parsedContent = new DOMParser().parseFromString(label, 'text/html').documentElement.textContent; // to match the partial start of word.
      // example if searchTerm is `select` and string contains `selected`

      var regexString = "^(" + escapeRegExp(currentValueTrimmed) + ")\\w+";
      var regex = new RegExp(regexString, 'i');
      var regexExecution = regex.exec(parsedContent); // if execution value is null it means either there is no match or there are chances
      // that exact word is present

      if (!regexExecution) {
        // regex to match exact word
        regexString = "^(" + escapeRegExp(currentValueTrimmed) + ")";
        regex = new RegExp(regexString, 'i');
        regexExecution = regex.exec(parsedContent);
      }

      if (regexExecution) {
        var matchedString = parsedContent.slice(regexExecution.index, parsedContent.length);
        var highlightedWord = matchedString.slice(currentValueTrimmed.length).split(' ').slice(0, wordsToShowAfterHighlight + 1).join(' ');
        var suggestionPhrase = currentValueTrimmed + "<mark class=\"highlight\">" + highlightedWord + "</mark>";
        var suggestionValue = "" + currentValueTrimmed + highlightedWord; // to show unique results only

        if (!suggestionMap[suggestionPhrase]) {
          suggestionMap[suggestionPhrase] = 1;
          return [].concat(agg, [_extends({}, rest, {
            label: suggestionPhrase,
            value: suggestionValue,
            isPredictiveSuggestion: true
          })]);
        }

        return agg;
      }

      return agg;
    }, []);
    return parsedSuggestion;
  }

  return [];
};
/**
 *
 * @param {array} fields DataFields passed on Search Components
 * @param {array} suggestions Raw Suggestions received from ES
 * @param {string} currentValue Search Term
 * @param {boolean} showDistinctSuggestions When set to true will only return 1 suggestion per document
 * @param {boolean} enablePredictiveSuggestions When set to true will return the predictive suggestions list instead of the deafult list
 */

var getSuggestions = function getSuggestions(fields, suggestions, value, showDistinctSuggestions, enablePredictiveSuggestions) {
  if (fields === void 0) {
    fields = [];
  }

  if (value === void 0) {
    value = '';
  }

  if (showDistinctSuggestions === void 0) {
    showDistinctSuggestions = true;
  }

  if (enablePredictiveSuggestions === void 0) {
    enablePredictiveSuggestions = false;
  }

  var suggestionsList = [];
  var labelsList = [];
  var skipWordMatch = false; //  Use to skip the word match logic, important for synonym

  var currentValue = value || '';

  var populateSuggestionsList = function populateSuggestionsList(val, parsedSource, source) {
    // check if the suggestion includes the current value
    // and not already included in other suggestions
    var isWordMatch = skipWordMatch || currentValue.trim().split(' ').some(function (term) {
      return String(val).toLowerCase().includes(term);
    }); // promoted results should always include in suggestions even there is no match

    if (isWordMatch && !labelsList.includes(val) || source._promoted) {
      var defaultOption = {
        label: val,
        value: val,
        source: source
      };

      var option = _extends({}, defaultOption);

      labelsList = [].concat(labelsList, [val]);
      suggestionsList = [].concat(suggestionsList, [option]);

      if (showDistinctSuggestions) {
        return true;
      }
    }

    return false;
  };

  var parseField = function parseField(parsedSource, field, source) {
    if (field === void 0) {
      field = '';
    }

    if (source === void 0) {
      source = parsedSource;
    }

    if (typeof parsedSource === 'object') {
      var fieldNodes = field.split('.');
      var label = parsedSource[fieldNodes[0]];

      if (label) {
        if (fieldNodes.length > 1) {
          // nested fields of the 'foo.bar.zoo' variety
          var children = field.substring(fieldNodes[0].length + 1);

          if (Array.isArray(label)) {
            label.forEach(function (arrayItem) {
              parseField(arrayItem, children, source);
            });
          } else {
            parseField(label, children, source);
          }
        } else {
          var val = extractSuggestion(label);

          if (val) {
            if (Array.isArray(val)) {
              if (showDistinctSuggestions) {
                return val.some(function (suggestion) {
                  return populateSuggestionsList(suggestion, parsedSource, source);
                });
              }

              val.forEach(function (suggestion) {
                return populateSuggestionsList(suggestion, parsedSource, source);
              });
            }

            return populateSuggestionsList(val, parsedSource, source);
          }
        }
      }
    }

    return false;
  };

  var traverseSuggestions = function traverseSuggestions() {
    if (showDistinctSuggestions) {
      suggestions.forEach(function (item) {
        fields.some(function (field) {
          return parseField(item, field);
        });
      });
    } else {
      suggestions.forEach(function (item) {
        fields.forEach(function (field) {
          parseField(item, field);
        });
      });
    }
  };

  traverseSuggestions();

  if (suggestionsList.length < suggestions.length && !skipWordMatch) {
    /*
    When we have synonym we set skipWordMatch to false as it may discard
    the suggestion if word doesnt match term.
    For eg: iphone, ios are synonyms and on searching iphone isWordMatch
    in  populateSuggestionList may discard ios source which decreases no.
    of items in suggestionsList
    */
    skipWordMatch = true;
    traverseSuggestions();
  }

  if (enablePredictiveSuggestions) {
    return getPredictiveSuggestions({
      suggestions: suggestionsList,
      currentValue: value,
      wordsToShowAfterHighlight: true
    });
  }

  return suggestionsList;
};
function parseCompAggToHits(aggFieldName, buckets) {
  if (buckets === void 0) {
    buckets = [];
  }

  return buckets.map(function (bucket) {
    // eslint-disable-next-line camelcase
    var doc_count = bucket.doc_count,
        key = bucket.key,
        data = bucket[aggFieldName];
    return _extends({
      _doc_count: doc_count,
      // To handle the aggregation results for term and composite aggs
      _key: key[aggFieldName] !== undefined ? key[aggFieldName] : key
    }, data);
  });
}
function isEqual(x, y) {
  if (x === y) return true;
  if (!(x instanceof Object) || !(y instanceof Object)) return false;
  if (x.constructor !== y.constructor) return false;
  /* eslint-disable */

  for (var p in x) {
    if (!x.hasOwnProperty(p)) continue;
    if (!y.hasOwnProperty(p)) return false;
    if (x[p] === y[p]) continue;
    if (typeof x[p] !== 'object') return false;
    if (!isEqual(x[p], y[p])) return false;
  }

  for (var _p in y) {
    if (y.hasOwnProperty(_p) && !x.hasOwnProperty(_p)) return false;
  }
  /* eslint-enable */


  return true;
}
var searchBaseMappings = {
  id: 'id',
  type: 'type',
  react: 'react',
  queryFormat: 'queryFormat',
  dataField: 'dataField',
  categoryField: 'categoryField',
  categoryValue: 'categoryValue',
  nestedField: 'nestedField',
  from: 'from',
  size: 'size',
  sortBy: 'sortBy',
  value: 'value',
  aggregationField: 'aggregationField',
  aggregationSize: 'aggregationSize',
  after: 'after',
  includeNullValues: 'includeNullValues',
  includeFields: 'includeFields',
  excludeFields: 'excludeFields',
  fuzziness: 'fuzziness',
  searchOperators: 'searchOperators',
  highlight: 'highlight',
  highlightField: 'highlightField',
  customHighlight: 'customHighlight',
  interval: 'interval',
  aggregations: 'aggregations',
  missingLabel: 'missingLabel',
  showMissing: 'showMissing',
  enableSynonyms: 'enableSynonyms',
  selectAllLabel: 'selectAllLabel',
  pagination: 'pagination',
  queryString: 'queryString',
  enablePopularSuggestions: 'enablePopularSuggestions',
  showDistinctSuggestions: 'showDistinctSuggestions',
  error: 'error',
  defaultQuery: 'defaultQuery',
  customQuery: 'customQuery',
  requestStatus: 'requestStatus',
  results: 'results',
  aggregationData: 'aggregationData',
  micStatus: 'micStatus',
  micInstance: 'micInstance',
  micActive: 'micActive',
  micInactive: 'micInactive',
  micDenied: 'micDenied',
  query: 'query',
  requestPending: 'loading',
  appbaseSettings: 'appbaseConfig',
  suggestions: 'suggestions',
  queryId: 'queryId',
  recentSearches: 'recentSearches',
  distinctField: 'distinctField',
  distinctFieldConfig: 'distinctFieldConfig',
  // ---------------- Methods -----------------------
  onMicClick: 'handleMicClick',
  triggerDefaultQuery: 'triggerDefaultQuery',
  triggerCustomQuery: 'triggerCustomQuery',
  recordClick: 'recordClick',
  recordConversions: 'recordConversions',
  subscribeToStateChanges: 'subscribeToStateChanges',
  unsubscribeToStateChanges: 'unsubscribeToStateChanges',
  // ---------------- Setter Methods ----------------
  setDataField: 'setDataField',
  setValue: 'setValue',
  setSize: 'setSize',
  setFrom: 'setFrom',
  setFuzziness: 'setFuzziness',
  setIncludeFields: 'setIncludeFields',
  setExcludeFields: 'setExcludeFields',
  setSortBy: 'setSortBy',
  setReact: 'setReact',
  setDefaultQuery: 'setDefaultQuery',
  setCustomQuery: 'setCustomQuery',
  setAfter: 'setAfter'
};
function btoa(input) {
  if (input === void 0) {
    input = '';
  }

  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var str = input;
  var output = ''; // eslint-disable-next-line

  for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1); // eslint-disable-line no-bitwise
  output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise
  ) {
    charCode = str.charCodeAt(i += 3 / 4);

    if (charCode > 0xff) {
      throw new Error('"btoa" failed: The string to be encoded contains characters outside of the Latin1 range.');
    }

    block = block << 8 | charCode; // eslint-disable-line no-bitwise
  }

  return output;
}

/**
 * Base class is the abstract class for SearchBase and SearchComponent classes.
 */
var Base = /*#__PURE__*/function () {
  // to enable the recording of analytics
  // auth credentials if any
  // custom headers object
  // es index name
  // es url

  /* ---- callbacks to create the side effects while querying ----- */

  /* ------ Private properties only for the internal use ----------- */
  // analytics instance
  // query search ID
  function Base(_ref) {
    var index = _ref.index,
        url = _ref.url,
        credentials = _ref.credentials,
        headers = _ref.headers,
        appbaseConfig = _ref.appbaseConfig,
        transformRequest = _ref.transformRequest,
        transformResponse = _ref.transformResponse;

    if (!index) {
      throw new Error(errorMessages.invalidIndex);
    }

    if (!url) {
      throw new Error(errorMessages.invalidURL);
    }

    this.index = index;
    this.url = url;
    this.credentials = credentials || '';

    if (appbaseConfig) {
      this.appbaseConfig = appbaseConfig;
    }

    if (transformRequest) {
      this.transformRequest = transformRequest;
    }

    if (transformResponse) {
      this.transformResponse = transformResponse;
    } // Initialize headers


    this.headers = {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    };

    if (this.credentials) {
      this.headers = _extends({}, this.headers, {
        Authorization: "Basic " + btoa(this.credentials)
      });
    }

    if (headers) {
      this.setHeaders(headers);
    } // Create analytics index


    this._analyticsInstance = AppbaseAnalytics.init({
      index: index,
      url: url,
      credentials: credentials
    });
  } // To to set the custom headers


  var _proto = Base.prototype;

  _proto.setHeaders = function setHeaders(headers) {
    this.headers = _extends({}, this.headers, headers);
  } // To set the query ID
  ;

  _proto.setQueryID = function setQueryID(queryID) {
    this._queryId = queryID;
  };

  return Base;
}();

var Results = /*#__PURE__*/function () {
  // An array of results obtained from the applied query.
  // Raw response returned by ES query
  // Results parser
  function Results(data) {
    var _this = this;

    _defineProperty(this, "setRaw", function (rawResponse) {
      // set response
      _this.raw = rawResponse;

      if (rawResponse.hits && rawResponse.hits.hits) {
        _this.setData(rawResponse.hits.hits);
      }
    });

    this.data = data || [];
  } // Total number of results found


  var _proto = Results.prototype;

  // Method to set data explicitly
  _proto.setData = function setData(data) {
    // parse hits
    var filteredResults = parseHits(data); // filter results & remove duplicates if any

    if (this.promotedData.length) {
      var ids = this.promotedData.map(function (item) {
        return item._id;
      }).filter(Boolean);

      if (ids) {
        filteredResults = filteredResults.filter(function (item) {
          return !ids.includes(item._id);
        });
      }

      filteredResults = [].concat(this.promotedData.map(function (dataItem) {
        return _extends({}, dataItem, {
          _promoted: true
        });
      }), filteredResults);
    } // set data


    if (this.parseResults) {
      this.data = this.parseResults(filteredResults, data);
    } else {
      this.data = filteredResults;
    } // Add click ids in data


    this.data = withClickIds(this.data);
  };

  _createClass(Results, [{
    key: "numberOfResults",
    get: function get() {
      // calculate from raw response
      if (this.raw && this.raw.hits) {
        return typeof this.raw.hits.total === 'object' ? this.raw.hits.total.value : this.raw.hits.total;
      }

      return 0;
    } // Total time taken by request (in ms)

  }, {
    key: "time",
    get: function get() {
      // calculate from raw response
      if (this.raw) {
        return this.raw.took;
      }

      return 0;
    } // no of hidden results found

  }, {
    key: "hidden",
    get: function get() {
      if (this.raw && this.raw.hits) {
        return this.raw.hits.hidden || 0;
      }

      return 0;
    } // An array of promoted results obtained from the applied query.

  }, {
    key: "promotedData",
    get: function get() {
      if (this.raw && this.raw.promoted) {
        return this.raw.promoted || [];
      }

      return [];
    } // no of promoted results found

  }, {
    key: "promoted",
    get: function get() {
      return this.promotedData.length || 0;
    } // An object of raw response as-is from elasticsearch query

  }, {
    key: "rawData",
    get: function get() {
      return this.raw || {};
    } // object of custom data applied through queryRules
    // only works when `enableAppbase=true`

  }, {
    key: "customData",
    get: function get() {
      if (this.raw && this.raw.customData) {
        return this.raw.customData || {};
      }

      return {};
    }
  }]);

  return Results;
}();

var Aggregations = /*#__PURE__*/function () {
  // An array of composite aggregations obtained from the applied aggs in options.
  // useful when loading data of greater size
  // Raw aggregations returned by ES query
  function Aggregations(data) {
    this.data = data || [];
  } // An object of raw response as-is from elasticsearch query


  var _proto = Aggregations.prototype;

  _proto.setRaw = function setRaw(rawResponse) {
    // set response
    this.raw = rawResponse;
    if (rawResponse.after_key) this.setAfterKey(rawResponse.after_key);
  };

  _proto.setAfterKey = function setAfterKey(key) {
    this.afterKey = key;
  } // Method to set data explicitly
  ;

  _proto.setData = function setData(aggField, data, append) {
    if (append === void 0) {
      append = false;
    }

    // parse aggregation buckets
    var parsedData = parseCompAggToHits(aggField, data); // Merge data

    if (append) {
      this.data = [].concat(this.data, parsedData);
    } else {
      this.data = parsedData;
    }
  };

  _createClass(Aggregations, [{
    key: "rawData",
    get: function get() {
      return this.raw || {};
    }
  }]);

  return Aggregations;
}();

var defaultOptions = {
  triggerDefaultQuery: true,
  triggerCustomQuery: false,
  stateChanges: true
};
var defaultOption = {
  stateChanges: true
};
var MIC_STATUS = {
  inactive: 'INACTIVE',
  active: 'ACTIVE',
  denied: 'DENIED'
};
var REQUEST_STATUS = {
  inactive: 'INACTIVE',
  pending: 'PENDING',
  error: 'ERROR'
};
var suggestionQueryID = 'DataSearch__suggestions';
/**
 * SearchComponent class is responsible for the following things:
 * - It provides the methods to trigger the query
 * - It maintains the request state for e.g loading, error etc.
 * - It handles the `custom` and `default` queries
 * - Basically the SearchComponent class provides all the utilities to build any ReactiveSearch component
 */

var SearchComponent = /*#__PURE__*/function (_Base) {
  _inheritsLoose(SearchComponent, _Base);

  // RS API properties
  // other properties
  // To enable the popular suggestions
  // size of the popular suggestions
  // To show the distinct suggestions
  // To show the predictive suggestions
  // preserve the data for infinite loading
  // to clear the dependent facets values on query change
  // query error
  // state changes subject
  // request status
  // results
  // aggregations
  // recent searches

  /* ------ Private properties only for the internal use ----------- */
  // Counterpart of the query
  // TODO: Check on the below properties
  // mic status
  // mic instance
  // query search ID

  /* ---- callbacks to create the side effects while querying ----- */

  /* ------------- change events -------------------------------- */
  // called when value changes
  // called when results change
  // called when composite aggregationData change
  // called when there is an error while fetching results
  // called when request status changes
  // called when query changes
  // called when mic status changes
  function SearchComponent(_ref) {
    var _this;

    var index = _ref.index,
        url = _ref.url,
        credentials = _ref.credentials,
        appbaseConfig = _ref.appbaseConfig,
        headers = _ref.headers,
        transformRequest = _ref.transformRequest,
        transformResponse = _ref.transformResponse,
        beforeValueChange = _ref.beforeValueChange,
        onValueChange = _ref.onValueChange,
        onResults = _ref.onResults,
        onAggregationData = _ref.onAggregationData,
        onError = _ref.onError,
        onRequestStatusChange = _ref.onRequestStatusChange,
        onQueryChange = _ref.onQueryChange,
        onMicStatusChange = _ref.onMicStatusChange,
        enablePopularSuggestions = _ref.enablePopularSuggestions,
        maxPopularSuggestions = _ref.maxPopularSuggestions,
        _results = _ref.results,
        showDistinctSuggestions = _ref.showDistinctSuggestions,
        enablePredictiveSuggestions = _ref.enablePredictiveSuggestions,
        preserveResults = _ref.preserveResults,
        clearOnQueryChange = _ref.clearOnQueryChange,
        rsAPIConfig = _objectWithoutPropertiesLoose(_ref, ["index", "url", "credentials", "appbaseConfig", "headers", "transformRequest", "transformResponse", "beforeValueChange", "onValueChange", "onResults", "onAggregationData", "onError", "onRequestStatusChange", "onQueryChange", "onMicStatusChange", "enablePopularSuggestions", "maxPopularSuggestions", "results", "showDistinctSuggestions", "enablePredictiveSuggestions", "preserveResults", "clearOnQueryChange"]);

    _this = _Base.call(this, {
      index: index,
      url: url,
      credentials: credentials,
      headers: headers,
      appbaseConfig: appbaseConfig,
      transformRequest: transformRequest,
      transformResponse: transformResponse
    }) || this;

    _defineProperty(_assertThisInitialized(_this), "onMicClick", function (micOptions, options) {
      if (micOptions === void 0) {
        micOptions = {};
      }

      if (options === void 0) {
        options = {
          triggerDefaultQuery: false,
          triggerCustomQuery: false,
          stateChanges: true
        };
      }

      var prevStatus = _this._micStatus;

      if (typeof window !== 'undefined') {
        window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition || null;
      }

      if (window && window.SpeechRecognition && prevStatus !== MIC_STATUS.denied) {
        if (prevStatus === MIC_STATUS.active) {
          _this._setMicStatus(MIC_STATUS.inactive, options);
        }

        var _window = window,
            SpeechRecognition = _window.SpeechRecognition;

        if (_this._micInstance) {
          _this._stopMic();

          return;
        }

        _this._micInstance = new SpeechRecognition();
        _this._micInstance.continuous = true;
        _this._micInstance.interimResults = true;
        Object.assign(_this._micInstance, micOptions);

        _this._micInstance.start();

        _this._micInstance.onstart = function () {
          _this._setMicStatus(MIC_STATUS.active, options);
        };

        _this._micInstance.onresult = function (_ref2) {
          var results = _ref2.results;

          if (results && results[0] && results[0].isFinal) {
            _this._stopMic();
          }

          _this._handleVoiceResults({
            results: results
          }, options);
        };

        _this._micInstance.onerror = function (e) {
          if (e.error === 'no-speech' || e.error === 'audio-capture') {
            _this._setMicStatus(MIC_STATUS.inactive, options);
          } else if (e.error === 'not-allowed') {
            _this._setMicStatus(MIC_STATUS.denied, options);
          }

          console.error(e);
        };
      }
    });

    _defineProperty(_assertThisInitialized(_this), "setDataField", function (dataField, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.dataField;
      _this.dataField = dataField;

      _this._applyOptions(options, 'dataField', prev, dataField);
    });

    _defineProperty(_assertThisInitialized(_this), "setParent", function (parent) {
      _this._parent = parent;
    });

    _defineProperty(_assertThisInitialized(_this), "setValue", function (value, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var performUpdate = function performUpdate() {
        var prev = _this.value;
        _this.value = value;

        _this._applyOptions(options, 'value', prev, _this.value);
      };

      if (_this.beforeValueChange) {
        _this.beforeValueChange(value).then(performUpdate)["catch"](function (e) {
          console.warn('beforeValueChange rejected the promise with ', e);
        });
      } else {
        performUpdate();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "setSize", function (size, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.size;
      _this.size = size;

      _this._applyOptions(options, 'size', prev, _this.size);
    });

    _defineProperty(_assertThisInitialized(_this), "setFrom", function (from, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.from;
      _this.from = from;

      _this._applyOptions(options, 'from', prev, _this.from);
    });

    _defineProperty(_assertThisInitialized(_this), "setFuzziness", function (fuzziness, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.fuzziness;
      _this.fuzziness = fuzziness;

      _this._applyOptions(options, 'fuzziness', prev, _this.fuzziness);
    });

    _defineProperty(_assertThisInitialized(_this), "setIncludeFields", function (includeFields, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.includeFields;
      _this.includeFields = includeFields;

      _this._applyOptions(options, 'includeFields', prev, includeFields);
    });

    _defineProperty(_assertThisInitialized(_this), "setExcludeFields", function (excludeFields, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.excludeFields;
      _this.excludeFields = excludeFields;

      _this._applyOptions(options, 'excludeFields', prev, excludeFields);
    });

    _defineProperty(_assertThisInitialized(_this), "setSortBy", function (sortBy, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.sortBy;
      _this.sortBy = sortBy;

      _this._applyOptions(options, 'sortBy', prev, sortBy);
    });

    _defineProperty(_assertThisInitialized(_this), "setReact", function (react, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.react;
      _this.react = react;

      _this._applyOptions(options, 'react', prev, react);
    });

    _defineProperty(_assertThisInitialized(_this), "setDefaultQuery", function (defaultQuery, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.defaultQuery;
      _this.defaultQuery = defaultQuery;

      _this._applyOptions(options, 'defaultQuery', prev, defaultQuery);
    });

    _defineProperty(_assertThisInitialized(_this), "setCustomQuery", function (customQuery, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.customQuery;
      _this.customQuery = customQuery;

      _this._applyOptions(options, 'customQuery', prev, customQuery);
    });

    _defineProperty(_assertThisInitialized(_this), "setAfter", function (after, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prev = _this.after;
      _this.after = after;

      _this.aggregationData.setAfterKey(after);

      _this._applyOptions(options, 'after', prev, after);
    });

    _defineProperty(_assertThisInitialized(_this), "triggerDefaultQuery", function (options) {
      if (options === void 0) {
        options = defaultOption;
      }

      // To prevent duplicate queries
      if (isEqual(_this._query, _this.componentQuery)) {
        return Promise.resolve(true);
      }

      var handleError = function handleError(err) {
        _this._setError(err, {
          stateChanges: options.stateChanges
        });

        console.error(err);
        return Promise.reject(err);
      };

      try {
        _this._updateQuery();

        _this._setRequestStatus(REQUEST_STATUS.pending);

        return _this._fetchRequest({
          query: Array.isArray(_this.query) ? _this.query : [_this.query],
          settings: _this.appbaseSettings
        }).then(function (results) {
          var prev = _this.results;
          var rawResults = results && results[_this.id];

          var afterResponse = function afterResponse() {
            if (rawResults.aggregations) {
              _this._handleAggregationResponse(rawResults.aggregations, _extends({
                defaultOptions: defaultOptions
              }, options));
            }

            _this._setRequestStatus(REQUEST_STATUS.inactive);

            _this._applyOptions({
              stateChanges: options.stateChanges
            }, 'results', prev, _this.results);
          };

          if ((!_this.type || _this.type === queryTypes.Search) && _this.enablePopularSuggestions) {
            _this._fetchRequest(_this.getSuggestionsQuery(), true).then(function (rawPopularSuggestions) {
              var popularSuggestionsData = rawPopularSuggestions[suggestionQueryID]; // Merge popular suggestions as the top suggestions

              if (popularSuggestionsData && popularSuggestionsData.hits && popularSuggestionsData.hits.hits && rawResults.hits && rawResults.hits.hits) {
                rawResults.hits.hits = [].concat((popularSuggestionsData.hits.hits || []).map(function (hit) {
                  return _extends({}, hit, {
                    // Set the popular suggestion tag for suggestion hits
                    _popular_suggestion: true
                  });
                }), rawResults.hits.hits);
              }

              _this._appendResults(rawResults);

              afterResponse();
            })["catch"](handleError);
          } else {
            _this._appendResults(rawResults);

            afterResponse();
          }

          return Promise.resolve(rawResults);
        })["catch"](handleError);
      } catch (err) {
        return handleError(err);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "triggerCustomQuery", function (options) {
      if (options === void 0) {
        options = defaultOption;
      }

      // Generate query again after resetting changes
      var _this$_generateQuery = _this._generateQuery(),
          requestBody = _this$_generateQuery.requestBody,
          orderOfQueries = _this$_generateQuery.orderOfQueries;

      if (requestBody.length) {
        if (isEqual(_this._query, requestBody)) {
          return Promise.resolve(true);
        }

        var handleError = function handleError(err) {
          _this._setError(err, {
            stateChanges: options.stateChanges
          });

          console.error(err);
          return Promise.reject(err);
        };

        try {
          // set the request loading to true for all the requests
          orderOfQueries.forEach(function (id) {
            var componentInstance = _this._parent.getComponent(id);

            if (componentInstance) {
              // Reset `from` and `after` values
              componentInstance.setFrom(0, {
                stateChanges: true,
                triggerDefaultQuery: false,
                triggerCustomQuery: false
              });
              componentInstance.setAfter(undefined, {
                stateChanges: true,
                triggerDefaultQuery: false,
                triggerCustomQuery: false
              }); // Reset value for dependent components after fist query is made
              // We wait for first query to not clear filters applied by URL params

              if (_this.clearOnQueryChange && _this._query) {
                componentInstance.setValue(undefined, {
                  stateChanges: true,
                  triggerDefaultQuery: false,
                  triggerCustomQuery: false
                });
              }

              componentInstance._setRequestStatus(REQUEST_STATUS.pending); // Update the query


              componentInstance._updateQuery();
            }
          }); // Re-generate query after changes

          var _this$_generateQuery2 = _this._generateQuery(),
              finalRequest = _this$_generateQuery2.requestBody;

          return _this._fetchRequest({
            query: finalRequest,
            settings: _this.appbaseSettings
          }).then(function (results) {
            // Update the state for components
            orderOfQueries.forEach(function (id) {
              var componentInstance = _this._parent.getComponent(id);

              if (componentInstance) {
                componentInstance._setRequestStatus(REQUEST_STATUS.inactive); // Update the results


                var _prev = componentInstance.results; // Collect results from the response for a particular component

                var rawResults = results && results[id]; // Set results

                if (rawResults.hits) {
                  componentInstance.results.setRaw(rawResults);

                  componentInstance._applyOptions({
                    stateChanges: options.stateChanges
                  }, 'results', _prev, componentInstance.results);
                }

                if (rawResults.aggregations) {
                  componentInstance._handleAggregationResponse(rawResults.aggregations, _extends({
                    defaultOptions: defaultOptions
                  }, options), false);
                }
              }
            });
            return Promise.resolve(results);
          })["catch"](handleError);
        } catch (err) {
          return handleError(err);
        }
      } else {
        return Promise.resolve({});
      }
    });

    _defineProperty(_assertThisInitialized(_this), "recordClick", function (objects, isSuggestionClick) {
      if (isSuggestionClick === void 0) {
        isSuggestionClick = false;
      }

      if (_this._analyticsInstance && _this.queryId) {
        _this._analyticsInstance.click({
          queryID: _this.queryId,
          objects: objects,
          isSuggestionClick: isSuggestionClick
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "recordConversions", function (objects) {
      if (_this._analyticsInstance && _this.queryId) {
        _this._analyticsInstance.conversion({
          queryID: _this.queryId,
          objects: objects
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "subscribeToStateChanges", function (fn, propertiesToSubscribe) {
      _this.stateChanges.subscribe(fn, propertiesToSubscribe);
    });

    _defineProperty(_assertThisInitialized(_this), "unsubscribeToStateChanges", function (fn) {
      _this.stateChanges.unsubscribe(fn);
    });

    _defineProperty(_assertThisInitialized(_this), "clearResults", function (options) {
      if (options === void 0) {
        options = defaultOption;
      }

      var prev = _this.results;

      _this.results.setRaw({
        hits: {
          hits: []
        }
      });

      _this._applyOptions({
        stateChanges: options.stateChanges
      }, 'results', prev, _this.results);
    });

    _defineProperty(_assertThisInitialized(_this), "getRecentSearches", function (queryOptions, options) {
      if (queryOptions === void 0) {
        queryOptions = {
          size: 5,
          minChars: 3
        };
      }

      if (options === void 0) {
        options = defaultOption;
      }

      var requestOptions = {
        headers: _extends({}, _this.headers)
      };
      var queryString = '';

      var addParam = function addParam(key, value) {
        if (queryString) {
          queryString += "&" + key + "=" + value;
        } else {
          queryString += key + "=" + value;
        }
      };

      if (_this.appbaseSettings && _this.appbaseSettings.userId) {
        addParam('user_id', _this.appbaseSettings.userId);
      }

      if (queryOptions) {
        if (queryOptions.size) {
          addParam('size', String(queryOptions.size));
        }

        if (queryOptions.from) {
          addParam('from', queryOptions.from);
        }

        if (queryOptions.to) {
          addParam('to', queryOptions.to);
        }

        if (queryOptions.minChars) {
          addParam('min_chars', String(queryOptions.minChars));
        }

        if (queryOptions.customEvents) {
          Object.keys(queryOptions.customEvents).forEach(function (key) {
            // $FlowFixMe
            addParam(key, queryOptions.customEvents[key]);
          });
        }
      }

      return new Promise(function (resolve, reject) {
        fetch(_this.url + "/_analytics/" + _this._getSearchIndex() + "/recent-searches?" + queryString, requestOptions).then(function (res) {
          if (res.status >= 500) {
            return reject(res);
          }

          if (res.status >= 400) {
            return reject(res);
          }

          return res.json().then(function (recentSearches) {
            var prev = _this.recentSearches;
            _this.recentSearches = recentSearches.map(function (searchObject) {
              return {
                label: searchObject.key,
                value: searchObject.key
              };
            });

            _this._applyOptions({
              stateChanges: options.stateChanges
            }, 'recentSearches', prev, _this.recentSearches);

            resolve(_this.recentSearches); // Populate the recent searches
          })["catch"](function (e) {
            console.warn('SearchBase: error while fetching the recent searches ', e);
            return reject(e);
          });
        })["catch"](function (e) {
          console.warn('SearchBase: error while fetching the recent searches ', e);
          return reject(e);
        });
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_handleVoiceResults", function (_ref3, options) {
      var results = _ref3.results;

      if (options === void 0) {
        options = defaultOptions;
      }

      if (results && results[0] && results[0].isFinal && results[0][0] && results[0][0].transcript && results[0][0].transcript.trim()) {
        _this.setValue(results[0][0].transcript.trim(), _extends({}, options, {
          triggerCustomQuery: true,
          triggerDefaultQuery: true
        }));
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_stopMic", function () {
      if (_this._micInstance) {
        _this._micInstance.stop();

        _this._micInstance = null;

        _this._setMicStatus(MIC_STATUS.inactive);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_setMicStatus", function (status, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var prevStatus = _this._micStatus;
      _this._micStatus = status;

      _this._applyOptions(options, 'micStatus', prevStatus, _this._micStatus);
    });

    var _id = rsAPIConfig.id,
        type = rsAPIConfig.type,
        _react = rsAPIConfig.react,
        queryFormat = rsAPIConfig.queryFormat,
        _dataField = rsAPIConfig.dataField,
        categoryField = rsAPIConfig.categoryField,
        categoryValue = rsAPIConfig.categoryValue,
        nestedField = rsAPIConfig.nestedField,
        _from = rsAPIConfig.from,
        _size = rsAPIConfig.size,
        _sortBy = rsAPIConfig.sortBy,
        _value = rsAPIConfig.value,
        aggregationField = rsAPIConfig.aggregationField,
        aggregationSize = rsAPIConfig.aggregationSize,
        _after = rsAPIConfig.after,
        includeNullValues = rsAPIConfig.includeNullValues,
        _includeFields = rsAPIConfig.includeFields,
        _excludeFields = rsAPIConfig.excludeFields,
        _fuzziness = rsAPIConfig.fuzziness,
        searchOperators = rsAPIConfig.searchOperators,
        highlight = rsAPIConfig.highlight,
        highlightField = rsAPIConfig.highlightField,
        customHighlight = rsAPIConfig.customHighlight,
        interval = rsAPIConfig.interval,
        aggregations = rsAPIConfig.aggregations,
        missingLabel = rsAPIConfig.missingLabel,
        showMissing = rsAPIConfig.showMissing,
        _defaultQuery = rsAPIConfig.defaultQuery,
        _customQuery = rsAPIConfig.customQuery,
        execute = rsAPIConfig.execute,
        enableSynonyms = rsAPIConfig.enableSynonyms,
        selectAllLabel = rsAPIConfig.selectAllLabel,
        pagination = rsAPIConfig.pagination,
        _queryString = rsAPIConfig.queryString,
        distinctField = rsAPIConfig.distinctField,
        distinctFieldConfig = rsAPIConfig.distinctFieldConfig;

    if (!_id) {
      throw new Error(errorMessages.invalidComponentId);
    } // dataField is required for components other then search


    if (type && type !== queryTypes.Search) {
      if (!_dataField) {
        throw new Error(errorMessages.invalidDataField);
      } else if (Array.isArray(_dataField)) {
        throw new Error(errorMessages.dataFieldAsArray);
      }
    }

    _this.id = _id;
    _this.type = type;
    _this.react = _react;
    _this.queryFormat = queryFormat;
    _this.dataField = _dataField;
    _this.categoryField = categoryField;
    _this.categoryValue = categoryValue;
    _this.nestedField = nestedField;
    _this.from = _from;
    _this.size = _size;
    _this.sortBy = _sortBy;
    _this.aggregationField = aggregationField;
    _this.aggregationSize = aggregationSize;
    _this.after = _after;
    _this.includeNullValues = includeNullValues;
    _this.includeFields = _includeFields;
    _this.excludeFields = _excludeFields;
    _this.fuzziness = _fuzziness;
    _this.searchOperators = searchOperators;
    _this.highlight = highlight;
    _this.highlightField = highlightField;
    _this.customHighlight = customHighlight;
    _this.interval = interval;
    _this.aggregations = aggregations;
    _this.missingLabel = missingLabel;
    _this.showMissing = showMissing;
    _this.execute = execute;
    _this.enableSynonyms = enableSynonyms;
    _this.selectAllLabel = selectAllLabel;
    _this.pagination = pagination;
    _this.queryString = _queryString;
    _this.defaultQuery = _defaultQuery;
    _this.customQuery = _customQuery;
    _this.beforeValueChange = beforeValueChange;
    _this.onValueChange = onValueChange;
    _this.onResults = onResults;
    _this.onAggregationData = onAggregationData;
    _this.onError = onError;
    _this.onRequestStatusChange = onRequestStatusChange;
    _this.onQueryChange = onQueryChange;
    _this.onMicStatusChange = onMicStatusChange;
    _this.distinctField = distinctField;
    _this.distinctFieldConfig = distinctFieldConfig; // other properties

    _this.enablePopularSuggestions = enablePopularSuggestions;
    _this.maxPopularSuggestions = maxPopularSuggestions;
    _this.showDistinctSuggestions = showDistinctSuggestions;
    _this.enablePredictiveSuggestions = enablePredictiveSuggestions;
    _this.preserveResults = preserveResults;
    _this.clearOnQueryChange = clearOnQueryChange; // Initialize the state changes observable

    _this.stateChanges = new Observable();
    _this.results = new Results(_results);
    _this.aggregationData = new Aggregations();

    if (_value) {
      _this.setValue(_value, {
        stateChanges: true
      });
    } else {
      _this.value = _value;
    }

    return _this;
  } // getters


  var _proto = SearchComponent.prototype;

  _proto.getSuggestionsQuery = function getSuggestionsQuery() {
    return {
      query: [{
        id: suggestionQueryID,
        dataField: popularSuggestionFields,
        size: this.maxPopularSuggestions || 5,
        value: this.value,
        defaultQuery: {
          query: {
            bool: {
              minimum_should_match: 1,
              should: [{
                function_score: {
                  field_value_factor: {
                    field: 'count',
                    modifier: 'sqrt',
                    missing: 1
                  }
                }
              }, {
                multi_match: {
                  fields: ['key^9', 'key.autosuggest^1', 'key.keyword^10'],
                  fuzziness: 0,
                  operator: 'or',
                  query: this.value,
                  type: 'best_fields'
                }
              }, {
                multi_match: {
                  fields: ['key^9', 'key.autosuggest^1', 'key.keyword^10'],
                  operator: 'or',
                  query: this.value,
                  type: 'phrase'
                }
              }, {
                multi_match: {
                  fields: ['key^9'],
                  operator: 'or',
                  query: this.value,
                  type: 'phrase_prefix'
                }
              }]
            }
          }
        }
      }]
    };
  } // use this methods to record a search click event
  ;

  /* -------- Private methods only for the internal use -------- */
  _proto._appendResults = function _appendResults(rawResults) {
    if (this.preserveResults && rawResults && Array.isArray(rawResults.hits && rawResults.hits.hits) && Array.isArray(this.results.rawData && this.results.rawData.hits && this.results.rawData.hits.hits)) {
      this.results.setRaw(_extends({}, rawResults, {
        hits: _extends({}, rawResults.hits, {
          hits: [].concat(this.results.rawData.hits.hits, rawResults.hits.hits)
        })
      }));
    } else {
      this.results.setRaw(rawResults);
    }
  } // Method to apply the changed based on set options
  ;

  _proto._applyOptions = function _applyOptions(options, key, prevValue, nextValue) {
    // // Trigger mic events
    if (key === 'micStatus' && this.onMicStatusChange) {
      this.onMicStatusChange(nextValue, prevValue);
    } // Trigger events


    if (key === 'query' && this.onQueryChange) {
      this.onQueryChange(nextValue, prevValue);
    }

    if (key === 'value' && this.onValueChange) {
      this.onValueChange(nextValue, prevValue);
    }

    if (key === 'error' && this.onError) {
      this.onError(nextValue);
    }

    if (key === 'results' && this.onResults) {
      this.onResults(nextValue, prevValue);
    }

    if (key === 'aggregationData' && this.onAggregationData) {
      this.onAggregationData(nextValue, prevValue);
    }

    if (key === 'requestStatus' && this.onRequestStatusChange) {
      this.onRequestStatusChange(nextValue, prevValue);
    }

    if (options.triggerDefaultQuery) {
      this.triggerDefaultQuery();
    }

    if (options.triggerCustomQuery) {
      this.triggerCustomQuery();
    }

    if (options.stateChanges !== false) {
      var _this$stateChanges$ne;

      this.stateChanges.next((_this$stateChanges$ne = {}, _this$stateChanges$ne[key] = {
        prev: prevValue,
        next: nextValue
      }, _this$stateChanges$ne), key, this);
    }
  };

  _proto._getSearchIndex = function _getSearchIndex(isPopularSuggestionsAPI) {
    if (isPopularSuggestionsAPI === void 0) {
      isPopularSuggestionsAPI = false;
    }

    var index = this.index;

    if (isPopularSuggestionsAPI) {
      index = '.suggestions';
    } else if (this._parent && this._parent.index) {
      index = this._parent.index;
    }

    return index;
  };

  _proto._fetchRequest = function _fetchRequest(requestBody, isPopularSuggestionsAPI) {
    var _this2 = this;

    if (isPopularSuggestionsAPI === void 0) {
      isPopularSuggestionsAPI = false;
    }

    // remove undefined properties from request body
    var requestOptions = {
      method: 'POST',
      body: JSON.stringify(requestBody),
      headers: _extends({}, this.headers)
    };
    return new Promise(function (resolve, reject) {
      _this2._handleTransformRequest(requestOptions).then(function (finalRequestOptions) {
        // set timestamp in request
        var timestamp = Date.now();
        var suffix = '_reactivesearch.v3';

        var index = _this2._getSearchIndex(isPopularSuggestionsAPI);

        return fetch(_this2.url + "/" + index + "/" + suffix, finalRequestOptions).then(function (res) {
          var responseHeaders = res.headers; // check if search component is present

          if (res.headers) {
            var queryID = res.headers.get('X-Search-Id');

            if (queryID) {
              // if parent exists then set the queryID to parent
              if (_this2._parent) {
                _this2._parent.setQueryID(queryID);
              } else {
                _this2.setQueryID(queryID);
              }
            }
          }

          if (res.status >= 500) {
            return reject(res);
          }

          if (res.status >= 400) {
            return reject(res);
          }

          return res.json().then(function (data) {
            _this2._handleTransformResponse(data).then(function (transformedData) {
              if (transformedData && Object.prototype.hasOwnProperty.call(transformedData, 'error')) {
                reject(transformedData);
              }

              var response = _extends({}, transformedData, {
                _timestamp: timestamp,
                _headers: responseHeaders
              });

              return resolve(response);
            })["catch"](function (e) {
              console.warn('SearchBase: transformResponse rejected the promise with ', e);
              return reject(e);
            });
          });
        })["catch"](function (e) {
          return reject(e);
        });
      })["catch"](function (e) {
        console.warn('SearchBase: transformRequest rejected the promise with ', e);
        return reject(e);
      });
    });
  } // Method to generate the final query based on the component's value changes
  ;

  _proto._generateQuery = function _generateQuery() {
    var _this3 = this;

    /**
     * This method performs the following tasks to generate the query
     * 1. Get all the watcher components for a particular component ID
     * 2. Make the request payload
     * 3. Execute the final query
     * 4. Update results and trigger events => Call `setResults` or `setAggregations` based on the results
     */
    if (this._parent) {
      var components = this._parent.getComponents();

      var watcherComponents = []; // Find all the  watcher components

      Object.keys(components).forEach(function (id) {
        var componentInstance = components[id];

        if (componentInstance && componentInstance.react) {
          var flattenReact = flatReactProp(componentInstance.react, id);

          if (flattenReact.indexOf(_this3.id) > -1) {
            watcherComponents.push(id);
          }
        }
      });
      var requestQuery = {}; // Generate the request body for watchers

      watcherComponents.forEach(function (watcherId) {
        var component = _this3._parent.getComponent(watcherId);

        if (component) {
          requestQuery[watcherId] = component.componentQuery; // collect queries for all components defined in the `react` property
          // that have some value defined

          var flattenReact = flatReactProp(component.react, component.id);
          flattenReact.forEach(function (id) {
            // only add if not present
            if (!requestQuery[id]) {
              var dependentComponent = _this3._parent.getComponent(id);

              if (dependentComponent && dependentComponent.value) {
                // Set the execute to `false` for dependent components
                var query = dependentComponent.componentQuery;
                query.execute = false; // Add the query to request payload

                requestQuery[id] = query;
              }
            }
          });
        }
      });
      return {
        requestBody: Object.values(requestQuery),
        orderOfQueries: watcherComponents
      };
    }

    return {
      requestBody: [],
      orderOfQueries: []
    };
  };

  _proto._handleTransformResponse = function _handleTransformResponse(res) {
    if (this.transformResponse && typeof this.transformResponse === 'function') {
      return this.transformResponse(res);
    }

    return new Promise(function (resolve) {
      return resolve(res);
    });
  };

  _proto._handleTransformRequest = function _handleTransformRequest(requestOptions) {
    if (this.transformRequest && typeof this.transformRequest === 'function') {
      return this.transformRequest(requestOptions);
    }

    return new Promise(function (resolve) {
      return resolve(requestOptions);
    });
  };

  _proto._handleAggregationResponse = function _handleAggregationResponse(aggsResponse, options, append) {
    if (options === void 0) {
      options = defaultOptions;
    }

    if (append === void 0) {
      append = true;
    }

    var aggregationField = this.aggregationField;

    if (!aggregationField && typeof this.dataField === 'string') {
      aggregationField = this.dataField;
    }

    var prev = this.aggregationData;
    this.aggregationData.setRaw(aggsResponse[aggregationField]);
    this.aggregationData.setData(aggregationField, aggsResponse[aggregationField].buckets, this.preserveResults && append);

    this._applyOptions({
      stateChanges: options.stateChanges
    }, 'aggregationData', prev, this.aggregationData);
  };

  _proto._setError = function _setError(error, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    this._setRequestStatus(REQUEST_STATUS.error);

    var prev = this.error;
    this.error = error;

    this._applyOptions(options, 'error', prev, this.error);
  };

  _proto._setRequestStatus = function _setRequestStatus(requestStatus) {
    var prev = this.requestStatus;
    this.requestStatus = requestStatus;

    this._applyOptions({
      stateChanges: true
    }, 'requestStatus', prev, this.requestStatus);
  } // Method to set the default query value
  ;

  _proto._updateQuery = function _updateQuery(query) {
    var _this4 = this;

    var prevQuery;
    prevQuery = _extends({}, this._query);
    var finalQuery = [this.componentQuery];
    var flattenReact = flatReactProp(this.react, this.id);
    flattenReact.forEach(function (id) {
      // only add if not present
      var watcherComponent = _this4._parent.getComponent(id);

      if (watcherComponent && watcherComponent.value) {
        // Set the execute to `false` for watcher components
        var watcherQuery = watcherComponent.componentQuery;
        watcherQuery.execute = false; // Add the query to request payload

        finalQuery.push(watcherQuery);
      }
    });
    this._query = query || finalQuery;

    this._applyOptions({
      stateChanges: false
    }, 'query', prevQuery, this._query);
  } // mic
  ;

  _createClass(SearchComponent, [{
    key: "micStatus",
    get: function get() {
      return this._micStatus;
    }
  }, {
    key: "micInstance",
    get: function get() {
      return this._micInstance;
    }
  }, {
    key: "micActive",
    get: function get() {
      return this._micStatus === MIC_STATUS.active;
    }
  }, {
    key: "micInactive",
    get: function get() {
      return this._micStatus === MIC_STATUS.inactive;
    }
  }, {
    key: "micDenied",
    get: function get() {
      return this._micStatus === MIC_STATUS.denied;
    }
  }, {
    key: "query",
    get: function get() {
      return this._query;
    }
  }, {
    key: "requestPending",
    get: function get() {
      return this.requestStatus === REQUEST_STATUS.pending;
    }
  }, {
    key: "appbaseSettings",
    get: function get() {
      var _ref4 = this.appbaseConfig || {},
          recordAnalytics = _ref4.recordAnalytics,
          customEvents = _ref4.customEvents,
          enableQueryRules = _ref4.enableQueryRules,
          userId = _ref4.userId;

      return {
        recordAnalytics: recordAnalytics,
        customEvents: customEvents,
        enableQueryRules: enableQueryRules,
        userId: userId
      };
    } // To get the parsed suggestions from the results

  }, {
    key: "suggestions",
    get: function get() {
      if (this.type && this.type !== queryTypes.Search) {
        return [];
      }

      if (this.results) {
        var fields = getNormalizedField(this.dataField) || [];

        if (fields.length === 0 && this.results.data && Array.isArray(this.results.data) && this.results.data.length > 0 && this.results.data[0]) {
          // Extract fields from _source
          fields = Object.keys(this.results.data[0]).filter(function (key) {
            return !['_id', '_click_id', '_index', '_score', '_type'].includes(key);
          });
        }

        if (this.enablePopularSuggestions) {
          // extract suggestions from popular suggestion fields too
          fields = [].concat(fields, popularSuggestionFields);
        }

        return getSuggestions(fields, this.results.data, this.value, this.showDistinctSuggestions, this.enablePredictiveSuggestions).slice(0, this.size);
      }

      return [];
    } // Method to get the raw query based on the current state

  }, {
    key: "componentQuery",
    get: function get() {
      return {
        id: this.id,
        type: this.type,
        dataField: getNormalizedField(this.dataField),
        react: this.react,
        highlight: this.highlight,
        highlightField: getNormalizedField(this.highlightField),
        fuzziness: this.fuzziness,
        searchOperators: this.searchOperators,
        includeFields: this.includeFields,
        excludeFields: this.excludeFields,
        size: this.size,
        from: this.from,
        queryFormat: this.queryFormat,
        sortBy: this.sortBy,
        fieldWeights: getNormalizedWeights(this.dataField),
        includeNullValues: this.includeNullValues,
        aggregationField: this.aggregationField,
        aggregationSize: this.aggregationSize,
        categoryField: this.categoryField,
        missingLabel: this.missingLabel,
        showMissing: this.showMissing,
        nestedField: this.nestedField,
        interval: this.interval,
        customHighlight: this.customHighlight,
        customQuery: this.customQuery ? this.customQuery(this) : undefined,
        defaultQuery: this.defaultQuery ? this.defaultQuery(this) : undefined,
        value: this.value,
        categoryValue: this.categoryValue,
        after: this.after,
        aggregations: this.aggregations,
        enableSynonyms: this.enableSynonyms,
        selectAllLabel: this.selectAllLabel,
        pagination: this.pagination,
        queryString: this.queryString,
        distinctField: this.distinctField,
        distinctFieldConfig: this.distinctFieldConfig,
        index: this.index
      };
    }
  }, {
    key: "queryId",
    get: function get() {
      // Get query ID from parent(searchbase) if exist
      if (this._parent && this._parent._queryId) {
        return this._parent._queryId;
      } // For single components just return the queryId from the component


      if (this._queryId) {
        return this._queryId;
      }

      return '';
    }
  }, {
    key: "mappedProps",
    get: function get() {
      var _this5 = this;

      var mappedProps = {};
      Object.keys(searchBaseMappings).forEach(function (key) {
        // $FlowFixMe
        mappedProps[searchBaseMappings[key]] = _this5[key];
      });
      return mappedProps;
    }
    /* -------- Public methods -------- */
    // mic click handler

  }]);

  return SearchComponent;
}(Base);

/**
 * SearchBase class will act like the ReactiveBase component.
 * It works as a centralized store that will have the info about active/registered components.
 */
var SearchBase = /*#__PURE__*/function (_Base) {
  _inheritsLoose(SearchBase, _Base);

  /* ------ Private properties only for the internal use ----------- */
  // active components
  function SearchBase(_ref) {
    var _this;

    var index = _ref.index,
        url = _ref.url,
        credentials = _ref.credentials,
        headers = _ref.headers,
        appbaseConfig = _ref.appbaseConfig;
    _this = _Base.call(this, {
      index: index,
      url: url,
      credentials: credentials,
      headers: headers,
      appbaseConfig: appbaseConfig
    }) || this;

    _defineProperty(_assertThisInitialized(_this), "register", function (componentId, component) {
      if (!componentId) {
        throw new Error(errorMessages.invalidComponentId);
      }

      if (_this._components[componentId]) {
        // return existing instance
        return _this._components[componentId];
      }

      var componentInstance = component;

      if (component && !(component instanceof SearchComponent)) {
        // create instance from object with all the options
        componentInstance = new SearchComponent(_extends({}, component, {
          id: componentId,
          index: component.index || _this.index,
          url: component.url || _this.url,
          credentials: component.credentials || _this.credentials,
          headers: component.headers || _this.headers,
          transformRequest: component.transformRequest || _this.transformRequest,
          transformResponse: component.transformResponse || _this.transformResponse,
          appbaseConfig: component.appbaseConfig || _this.appbaseConfig
        }));
      } else {
        // set the id property on instance
        componentInstance.id = componentId;
      } // register component


      _this._components[componentId] = componentInstance; // set the search base instance as parent

      componentInstance.setParent(_assertThisInitialized(_this));
      return componentInstance;
    });

    _defineProperty(_assertThisInitialized(_this), "unregister", function (componentId) {
      if (componentId) {
        delete _this._components[componentId];
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getComponent", function (componentId) {
      return _this._components[componentId];
    });

    _defineProperty(_assertThisInitialized(_this), "getComponents", function () {
      return _this._components;
    });

    _this._components = {};
    return _this;
  } // To register a component


  return SearchBase;
}(Base);

export { SearchBase, SearchComponent };
